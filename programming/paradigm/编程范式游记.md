# 编程范式游记
编程范式的英语是 Programming Paradigm, 范即模范之意, 范式即模式, 方法, 是一类典型的编程风格, 是指从事软件工程的一类典型的风格(方法学).
**无论是传统世界, 还是编程世界, 我们都在干一件事情. 那就是通过使用一种更为通用的方式, 即抽象和隔离, 让复杂的 "世界" 变得简单一些**.
在编程世界中, 我们需要处理好两件事:
* 编程语言中的类型问题.
* 对真实世界中业务代码的抽象, 重用和拼装.

## 泛型
C 语言的类型泛型基本上来说就是使用 `void*` 关键字或是使用宏定义.
**真正的泛型除了适配数据类型外, 还要适配数据结构**.
理想情况下, 算法应是和数据结构以及类型无关的, 各种特殊的数据类型理应做好自己分内的工作, 算法只关心一个标准的实现.
一个良好的泛型编程需要解决以下问题:
* 算法的泛型;
* 类型的泛型;
* 数据结构的泛型.

要做到泛型, 我们需要:
* 标准化掉类型的内存分配, 释放和访问.
* 标准化掉类型的操作. 如比较, I/O, 复制等.
* 标准化掉数据容器的操作. 如查找算法, 过滤算法, 聚合算法等.
* 标准化掉类型上特有的操作. 需要有标准化的接口来回调不同类型的具体操作.

**泛型的本质是屏蔽掉数据和操作数据的细节, 让算法更为通用, 让编程者更多地关注算法的结构, 而不是在算法中处理不同的数据类型**.

### 类型系统
**类型是对底层内存布局的一个抽象**.
类型的本质:
* 对内存的一种抽象. 不同的类型, 会有不同的内存布局和内存分配策略.
* 不同的类型, 有不同的操作. 所以, 对于特定的类型, 也有特定的一组操作.

程序语言的类型系统的主要功能有:
* 语言类型的安全性.
* 利于编译器的优化.
* 代码的可读性.
* 抽象化.

每个编程语言都需要一个类型检查系统:
* 静态类型检查是编译器进行语义分析时进行的. 如果一个语言强制实行类型规则(即通常只允许以不丢失信息为前提的自动类型转换), 那么称此处理为强类型, 反之称为弱类型.
* 动态类型检查系统更多的是在运行时期做动态类型标记和相关检查.


## 函数式编程
对于函数式编程来说, 它只关心定义输入数据和输出数据相关的关系, 数学表达式里面其实是在做一种映射, 输入的数据和输出的数据关系是什么样的, 是用函数来定义的.
特点:
* stateless: 函数不维护任何状态.
* immutable: 输入数据是不能动的. 返回的是新的数据集.

优势:
* 没有状态就没有伤害.
* 并行执行无伤害.
* Copy-Paste 重构代码无伤害.
* 函数的执行没有顺序上的问题.
* 惰性求值, 这需要编译器的支持.
* 确定性. 同一参数, 永远只会有一个结果.

劣势:
* 数据复制比较严重.

函数式编程关注的是描述问题, 而不是怎么实现(describe what to do, rather than how to do it). 所以, 我们把过程式编程范式叫做 Imperative Programming(指令式编程), 把函数式编程范式叫做 Declarative Programming(声明式编程).
函数式语言有三套件: Filter, Map, Reduce(过滤, 加工, 处理).
使用 Map&Reduce, 不要使用循环. 循环会让我们只能使用顺序型的数据结构.
**map 和 reduce 不关心源输入数据, 它们只是控制, 并不是业务. 控制是描述怎么干, 而业务是描述要干什么**.
管道(pipeline)把若干个命令串起来, 前面命令的输出成为后面命令的输入, 如此完成一个流式计算.
管道的设计哲学就是 KISS -- 让每个功能就做一件事, 并把这件事做到极致.
Unix 中经典技术的实践或理论, 往往是可以反映到分布式架构的. 一个好的分布式架构师, 通常都是对这些传统的微观上的经典技术有非常深刻的认知, 因为这些东西在方法论上都是相通的.

函数式编程的核心思想是将运算过程尽量写成一系列嵌套的函数调用, 关注的是做什么而不是怎么做, 因而被称为声明式编程. 以 Stateless(无状态) 和 Immutable(不可变)为主要特点, 代码简洁, 易于理解, 能便于进行并行执行, 易于做代码重构, 函数执行没有顺序上的问题, 支持惰性求值, 具有函数的确定性 -- 无论在什么场景下都会得到同样的结果.


## Decorator 模式
又叫修饰器模式, 装饰器模式.
修饰器模式就是扩展现有的函数的功能. 可以很容易地将一些非业务功能的代码抽象出来.
注解(Annotation)就是修饰器模式的典型应用.

## 面向对象编程
面向对象的编程有三大特性: 封装, 继承和多态.
它将对象作为程序的基本单元, 将程序和数据封装其中, 以提高软件的可重用性, 灵活性和可扩展性.
**函数式编程强调动词, 而面向对象强调名词**, 面向对象更多的关注接口间的关系, 而通过多态来适配不同的具体实现.
使用接口抽象具体实体类. 然后其它类耦合的是接口而不是实现类. 这就是多态, 其增加了程序的可扩展性. 这就是面向接口编程.
SOLID: 单一功能, 开闭原则, 里氏替换, 接口隔离以及依赖反转, 是面向对象设计的五个基本原则.
IoC/DIP(控制反转/依赖倒置): 系统之间的交互依赖于接口和标准, 而不是具体业务.

## 基于原型的编程范式
基于原型(Prototype)的编程其实也是面向对象编程的一种方式. 没有 class 化的, 直接使用对象. 又叫基于实例的编程. 其主流的语言是 JavaScript.
**很多基于原型的系统提倡运行时进行原型的修改(动态属性)**.
JavaScript 中的原型属性:
* `__proto__`: 实例对象的一个属性, 用来产生一个链接, 一个原型链, 用于寻找方法名或属性等.
* `prototype`: 是用 `new` 创建对象时构造 `__proto__` 用的. 它是构造函数的一个属性.

在 JavaScript 中, 对象有两种表现形式, 一种是 Object, 一种是 Function. **可以简单的认为, `__proto__` 是所有对象用于链接原型的一个指针**, 对于超级对象 Function 而言, `Function.__proto__` 的默认指向为  `Function.prototype`.
在 ES5 中, 规定原型继承需要使用 `Object.create()` 函数.
原型的思想就是一种委托的方式. 在使用委托的基于原型的语言中, 运行时语言可以 "仅仅通过序列的指针找到匹配" 这样的方式来定位属性或者寻找正确的数据. 所有这些创建行为, 共享行为需要的是委托指针.

## Go 语言的委托模式
声明一个 struct, 然后直接把这个 struct 类型放到另一个 struct 中(内嵌).

## 编程的本质

Programs = Algorithms + Data Structures
Algorithm = Logic + Control 

**任何算法都会有两个部分, 一个是 Logic 部分, 这是用来解决实际问题的. 另一个是 Control 部分, 这是用来决定用什么策略来解决问题. Logic 部分是真正意义上的解决问题的算法, 而 Control 部分只是影响解决这个问题的效率. 程序运行的效率问题和程序的逻辑其实是没有关系的. 如果将 Logic 和 Control 部分有效地分开, 那么代码就会变得更容易改进和维护**.

就像我们面向对象中依赖于接口而不是实现一样, 接口是对逻辑的抽象, 真正的逻辑放在不同的具现类中, 通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理.
**有效地分离 Logic, Control 和 Data 是写出好程序的关键所在**:
* Control 是可以标准化的. 比如遍历数据, 查找数据, 多线程, 并发, 异步等.
* 因为 Control 需要处理数据, 所以标准化 Control, 需要标准化 Data Structure, 我们可以通过泛型编程来解决这个事.
* 而 Control 还要处理用户的业务逻辑, 即 Logic. 所以, 我们可以通过标准化接口/协议来实现, 我们的 Control 模式可以适配于任何的 Logic.

**绝大多数程序复杂混乱的根本原因是业务逻辑与控制逻辑的紧密耦合**.
如何分离 Control 和 Logic 呢? 可以使用以下技术:
* State Machine: 状态定义, 状态变迁条件, 状态的 action.
* DSL(Domian Specific Language): HTML, SQL 等.
* 编程范式: 面向对象, 函数式编程, 逻辑推导式编程.

这就是编程的本质: Logic 部分才是真正有意义的(What), Control 部分只是影响 Logic 部分的效率(How).


## 逻辑编程范式
Prolog(Programming in Logic)是一种逻辑编程语言, 它创建在逻辑学的理论基础之上.
通过陈述事实(因果关系), 程序自动推导出相关的逻辑.

## 程序世界的编程范式
编程范式有声明式, 命名式, 逻辑式, 函数式, 面向对象的, 面向过程的.


## Refs
* [编程范式游记](https://time.geekbang.org/column/intro/209)
* 