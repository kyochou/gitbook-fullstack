# 从零开始学游戏开发
## 游戏开发基础知识
从硬件来讲, 游戏大致可以分为四大类:
1. 主机游戏(Console Game). 这类游戏的硬件可以插在电视机或显示屏上. 比如 Xbox, PS, Switch 等.
2. 电脑游戏.
3. 移动游戏.
4. 电视机游戏.

手游的开发需要更多的考量资源的分配和占比, 发布包的大小就是一个考验.
从画面方面考虑, 开发 2D 游戏只需要你知道 X 和 Y 的位置即可, 其他深层次的知识, 引擎都可以替你完成.
**对于初学者来说, 我们首先需要掌握核心的开发流程**, 至于过于细节的知识, 可以在有了一定基础后再进行拓展学习.

### 2D 游戏与 3D 游戏的区别
2D 游戏的类型:
1. 横版游戏. 主要特点是这种 2D 平面的画面只有左右两侧可以控制, 玩家体验通常比较顺畅.
2. 俯视视角游戏. 这类游戏提供一个空中俯视的视角给玩家, 能很清晰地看到游戏中呈现的所有地图和区域.
3. 斜 45 度角的视角游戏("伪 3D/2.5D"游戏). 

2D 游戏与 3D 游戏的区别:
1. 呈现画面. 3D 较之 2D 画面有更强大的冲击力和震撼力. 要做出一款好的 2D 游戏, 要比 3D 游戏下更多的功夫, 特别是在游戏的内涵, 创意, 音乐和细节上面.
2. 文件体积. 3D 的模型, 骨骼, 动作, 贴图等资源会占用大量的空间.

"伪 3D" 游戏是指将 2D 和 3D 技术结合起来, 实现 3D 游戏的体验. 也称 2.5D 游戏.
2D 游戏引擎无法制作狭义的 3D 游戏, 而 3D 游戏引擎则可以做 2D 游戏. 将 3D 游戏的视角和控制锁定在只有 2D 能呈现的范围内, 让玩家误以为是 2D 游戏, 但这类游戏可以借助 3D 引擎来优化游戏的声光和绚丽的特效, 让 2D 游戏更大放异彩.
在移动端的表现上, 2D 游戏其实和 3D 游戏不相上下.
所谓的 Z 值, 就是除了 X, Y 的长宽之外, 还多了一个高度值. 这个值也可以用在 2D 游戏中.
2D 渲染场景使用伪 3D 技术, 一般是因为机能限制或者 3D 技术不成熟, 但实际的实现难度不会比纯 3D 技术更简单.
2D 美术一般都是手绘, 如果需求改动特别明显, 那一系列跟该角色相关的图案都需要手工调整, 工作量很大.
准确地讲, 2D 游戏是 2D 图像图形进行线性的一些变换将之渲染至屏幕而成. 而 3D 的游戏是将 3D 的图形图像进行 3D 线性变换然后投影(Projection)至显示器(显示器是 2D 的)而成. 显示器在视觉上形成远近大小的效果, 让我们看起来是立体的. 事实上, 我们眼睛的视网膜也是这么工作的.
游戏的本质就是供人娱乐, 给人各种开心的, 刺激的, 恐怖的感官刺激.

### 游戏引擎
从专业的角度讲, 游戏引擎是完成开发一套游戏的解决方案, 而不仅仅涉及图形部分.
大多数游戏引擎包含以下系统: 渲染引擎, 物理引擎, 碰撞检测系统, 音效, 脚本引擎, 电脑动画, 人工智能, 网络引擎以及场景管理.
在代码层面, 游戏引擎是对绘图接口, 操作系统, 音频等接口进行的封装; 在工具层面, 游戏引擎是一整套游戏内容的制作工具, 方便你制作针对这个引擎的游戏内容.
了解游戏引擎, 会让你对游戏编程的总体脉络有一个了解.

### 地图编译器
关卡编辑器是一种主要给策划使用的编辑器, 它涉及地图中的关卡内容. 一般情况下, 关卡编辑器不涉及具体的地图细节, 但是它涉及总体的游戏地图和游戏流程.
关卡编辑器和地图编辑器的功能, 就好比家装设计图和房屋结构朝向图, 一个是在地图内设置物件的摆放位置和具体的表现形式; 一个是设计地图本身.
游戏 Demo 所肩负的任务, 就是完成该游戏总体的核心内容框架. 在这个框架内, 我们可以一窥游戏的总体逻辑, 想呈现给玩家的是什么内容.
和地图编辑器一样, 第一次编写游戏 Demo, 会有来自策划, 美术, 程序等各方面的意见和讨论, 而制作游戏 Demo 的过程对磨合团队是非常有利的.
游戏开发的常规流程有地图编辑器, 关卡编辑器, 游戏 Demo, 正式开发等.

## 客户端开发
所有长时间运行的程序, 包括游戏, 包括 Windows 本身都是一个大循环.
游戏内的代码几乎都在循环内完成. 一个循环完成一次绘制, 后一个循环刷新前一次的绘制. 最终类似电影一样, 完成整个动画的绘制以及不间断的操作.

### 图形和图像
严格来说, 图形(矢量图)其实是图像(像素图)的一种抽象表现形式.
从计算机最底层的程序(显卡处理)来看, 绘制图形和图像所经过的硬件处理几乎是一样的.

### 绘制游戏背景
所谓左右卷轴, 就是游戏画面是横向的, 左右运动的, 而上下卷轴就是游戏画面是竖直向的, 上下运动的.
绘制不等于显示. 想象游戏的每一帧就像电影的每一帧. 如果下一帧不去主动更新屏幕, 那么屏幕内容永远不会更新. 所以, 显示(`update`)的功能就是更新之前的所有(绘制)动作, 只有 `update` 一次, 屏幕的画面才会往前行进一次.

### 遮挡
在一些 2D 引擎中, 会有一个 Z 值的概念, Z 值就是在 X,Y 的基本 2D 位置上, 加入了高度的概念. 它模仿 3D 的 Z 值, 只是作遮挡用.
地图的数据文件会告诉你, 哪些坐标是有物件挡住的, 不能走; 哪些坐标有哪些物件, 你需要走过去的时候被遮挡.
一般的做法是, 我们会在多线程中绘制人物, 然后载入地图, 我们会在人物移动的过程中, 判断地图上的物件, 然后进行 Z 值的调整.
**在做遮挡的时候, 要考虑绘制顺序, 先绘制的一定会被后绘制的遮挡**.

### Sprite
精灵(Sprite), 多用于游戏中的人物和可移动物品. 也可用于显示鼠标指针和输入的文字.
从宏观的概念讲, 精灵就是一幅图片. 这些图片可以变形, 放大, 缩小, 或者是一系列的动画帧等.
alpha 混合就是将一部分被遮盖的图像进行半透明处理. 每动态修改一次 alpha 值, 就会让图像更透明或者更不透明. 
32 位的颜色值包含 RGB 以及 A(alpha), 每个值占 8 位.
在游戏中, 碰撞属于物理引擎的一部分. 特别是在 3D 游戏中, 物理引擎是独立于图形引擎的一个模块.
普通图像碰撞的检测, 是通过判断图像 x 轴和 y 轴是否重叠来实现的. 通过检测碰撞点的 alpha 值, 可实现碰撞部位(不透明表示是实物)的检测.

### 资源
素材应该放在资源包内的虚拟目录中.
所谓的资源包, 就是将游戏的所有资源和素材, 进行打包分类, 并且进行资源整合, 亦或将资源和素材进行压缩, 减少游戏体积.

### 嵌入脚本语言
使用脚本语言, 是为了能够在编写硬代码的同时, 也能很方便地, 不需要重新编译地编写逻辑代码.
Lua 脚本足够轻量, 几乎没有冗余的代码. Lua 虚拟机的执行效率几乎可以媲美 C/C++ 的执行效率.
Lua 可以说是一种胶水语言. 它的作用是粘合系统语言(C/C++)和上层脚本逻辑. 使用胶水语言, 就像是使用一种动态的配置文件.

## 服务器端开发
自定义协议包需要考虑完整性和安全性. 接收方需要知道协议的长度, 或者知道协议的尾部在哪里, 就可以保证协议包的完整性. 通过给协议包加密, 就可以保证安全性.

### 心跳检测
心跳包允许你每隔一定时间发送数据给服务器端, 告诉服务器我还活着, 否则服务器就当它已经死了, 确认超时, 并且退出.
在 TCP/IP 的协议层中, 本身是存在心跳包的设计的, 就是 TCP 协议中的 SO_KEEPALIVE.
 
 
## 其它
用户带上 VR 眼镜后, 一只眼睛只能看到奇数帧图像, 另一只眼睛只能看到偶数帧图像. 奇, 偶帧之间的不同, 也就因此视差产生了立体感.
NPC 是最简单, 但也是最难做好的.
制约移动设备发展的, 并不是技术本身, 或者将芯片做小的能力, 具体来说是电池. 只有解决了电源问题, 科技才可能有质的飞跃.
游戏开发是一门异常复杂的综合性艺术创作. 制作游戏不仅仅包含开发, 还包含创意, 资源调配, 产品规划等等.
开发游戏的时候, 策划要先行, 先出策划稿, UI 图, 页面迁徙图等; 然后美术开始跟上, 根据策划文案开始制作 UI, 原画, 人物, 场景等; 程序员开始制作各种编辑器和周边工具; 随后美术开始制作地图和各种关卡, 程序员开始编写 Demo; 随后就开始内部测试和运行, 总结问题和经验, 修正和补缺; 最后, 开始第一个正式版本的开发.
一般人提倡的学习路径是由浅入深, 但如果你想一直在技术领域深耕下去, 建议你走一条由难到易的学习路径. 先学习底层知识, 这样你在后续的高级语言的学习中, 就会相对的轻松和快速.

