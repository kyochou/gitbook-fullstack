# 二进制
## 存储
在实际的硬件系统中, 计算机 CPU 的运算器只实现了加法器, 而没有实现减法器. 减法是通过加上一个负数达到目的.
人们把二进制数分为有符号数(signed)和无符号数(unsigned). 有符号数的符号位是其二进制数中的最高位, 为 1 则表示此数为负.
对计算机而言, 无论是何种数据类型, 都有一个下限和上限. 超出这个限定, 就会发生溢出(overflow).


### 整数
#### 原码和补码
**在计算机系统中, 整数一律用补码存储. 正数的补码为其原码, 负数的补码是其反码值加一并丢掉溢出值**.
"原码" 就是我们看到的数值二进制的原始表示. 我们向计算机输入整数的二进制值时, 就是使用原码的形式输入的.
"反码" 是用来处理负数的, 其值为二进制值中的符号位不变, 其余位置取反. 反码用来解决原码中相同整数的正负二进制值相加不等于 0 的问题. 但在反码的表示中存在有两个零(+0 和 -0), 我们希望只有一个 0, 所以发明了 "补码". 补码的值是在反码的基础上加 1, 再丢掉溢出位(如果有的话), 这样, 在负数的补码值中, -0 和 +0 就相同了. 同样, 相同整数的正负值相加时(原码 + 补码), 只要丢掉溢出位即可. 所以, "补码" 是负整数在存储中的二进制值格式.
参考: [原码、反码、补码的产生、应用以及优缺点有哪些？ - 插画-李俊达的回答 - 知乎](https://www.zhihu.com/question/20159860/answer/71256667)






## 位运算
### complement
`~`, 按位取反运算. 一元运算符. 0 变 1, 1 变 0.

### AND
`&`, 按位与运算. 值全为 1 时结果才为 1.
验证奇偶数: 偶数的二进制最后一位总是 0, 奇数的二进制最后一位总是 1. 因此, 对于给定的某个数字, 我们可以把它和数字 1 进行按位 "与" 操作来判断其的奇偶性(`i&1 == 0`).

### OR
`|`, 按位或运算. 值有一个为 1 则结果为 1.

### XOR
`^`, 按位异或运算. 两值相同时, 结果为 0; 两值不同时, 结果为 1.
所有数值和自身进行按位的 "异或" 操作之后都为 0, 这是两个数值相等的必要充分条件.
如果使用同一个操作数对一个值连续做两次 XOR, 会返回这个值本身. XOR 的这个特点, 使得它可以用于信息的加密.

```js
message XOR key // cipherText
cipherText XOR key // message
```



位操作运算符 `&^` 用于按位置零(AND NOT). 对于表达式 `z = x &^ y`, 如果 y 的 bit 位为 1 的话, 则 z 的 bit 位为 0; 否则对应的 bit 位等于 x 相应的 bit 位的值.

```go
var x uint8 = 1<<1 | 1<<5
var y uint8 = 1<<1 | 1<<2

fmt.Printf("%08b\n", x) // 00100010
fmt.Printf("%08b\n", y) // 00000110
fmt.Printf("%08b\n", x&y) // 位运算 AND, 00000010
fmt.Printf("%08b\n", x|y) // 位运算 OR, 00100110
fmt.Printf("%08b\n", x^y) // 位运算 XOR, 00100100
fmt.Printf("%08b\n", x&^y) // 位运算 AND NOT, 00100000
fmt.Printf("%08b\n", x<<1) // 位运算左移, 01000100
fmt.Printf("%08b\n", x>>1) // 位运算右移, 00010001
```
位运算操作数最好使用无符号数, 这样你可以将整数完全当作一个 bit 位模式处理(不需要考虑符号位).
**无符号数往往只有在位运算或其它特殊的运算场景才会使用, 像 bit 集合, 分析二进制文件格式或者是哈希和加密操作等. 它们通常并不用于仅仅是表达非负数量的场合**.