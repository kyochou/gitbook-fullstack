# Interface
在计算机科学中, 接口是计算机系统中多个组件共享的边界, 不同的组件能够在边界上交换信息. **接口的本质就是引入一个新的中间层, 调用方可以通过接口与具体实现分离, 解除上下游的耦合, 上层的模块不再需要依赖下层的具体模块, 只需要依赖一个约定好的接口**.   
除了解耦有依赖关系的上下游, 接口还能够帮助我们隐藏底层实现, 减少关注点.   

接口定义一个对象的行为. 接口只指定了对象应该做什么, 至于如何实现这个行为, 则由对象本身去确定.   

在 Go 语言中, 接口的实现都是隐式的. 接口定义一套方法的集合, 任何实现这些方法的对象都可以被认为实现了这个接口, 这也称作 `Duck Type`. 这不像其他语言比如 java 需要预先声明类型实现了某个或某些接口, 这使得 Go 语言的接口和类型变得很轻量级, 它解耦了接口和具体实现的硬绑定.    

> If something looks like a duck, swims like a duck and quacks like a duck then it's probably a duck.    


Go 中实现接口的方式与 Java 完全不同:   
* 在 Java 中, 实现接口需要显式的声明接口并实现所有方法;  
* 在 Go 中, 实现接口的所有方法就隐式的实现了接口;   

接口也是 Go 中的一种类型. Go 中有两种略微不同的接口类型, 一种是带有一组方法的接口, 另一种是不带任何方法的空接口(`interface{}`).   
与 C 语言中的 `void *` 不同, 空接口 `interface{}` 类型不是任意类型, 如果我们将一个变量的类型转换成了 `interface{}`, 那么它在运行期间的类型也会发生变化, 获取其类型时就会得到 `interface{}`.   

Go 语言接口的理解:
* `interface` 是方法声明的集合;  
* 任何类型的对象实现了在 `interface` 中声明的全部方法, 则表明该类型实现了这个接口;   
* `interface` 可以作为一种数据类型, 实现了该接口的任何对象都可以给对应的接口类型变量赋值;    



