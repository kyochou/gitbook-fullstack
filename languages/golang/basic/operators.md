# 操作符

## ...
```go
// 用于不定参数的定义
func Foo(args ...interface{}) {
  for _, arg := range args {
    fmt.Println(arg)
  }
}
// 用于传递不定参数
args := []interface{}{1, false, "hello"}
Foo(args...)

// 用于定义动态的数组长度
arr := [...]int{1,2,4}
```

## == 
判等操作(`==`)的前提是, 两个操作数类型必须相同.    
只要遵循 `IEEE 754` 标准的编程语言都会有浮点数精度的问题. 尽量不要直接做浮点数比较, 确实需要比较时, 计算两个浮点数差的绝对值, 如果小于一定的值(比如 `1e-9`)就认为它们相等.   
复合类型(数组和结构体)的判等操作是逐 `元素/字段` 比较的.   
引用类型的比较实际判断的是两个变量是不是指向同一地址, 它不会去比较实际指向的数据.   
关于引用类型, 有两个比较特殊的规定:   
* 切片之间不允许比较, 切片只能与 `nil` 值比较;   
* `map` 之间不允许比较, `map` 只能与 `nil` 值比较;    

接口类型的比较会分别比较接口的类型和接口类型的值, 只有当类型相同(不需要完全相同, 满足 `is` 关系即可)且类型值相等时, 两个接口才相等.   
如果接口的类型值为不可比较类型, 强行比较会导致 `panic`.    

由于 `map` 的 `key` 是使用 `==` 来判等的, 所以所有不可比较的类型都不能做为 `map` 的 `key`.   

### Refs
* [深入理解Go之==](https://darjun.github.io/2019/08/20/golang-equal/)   


## Refs
* [Go 编程：那些隐晦的操作符](https://www.gitdig.com/go-operators/)