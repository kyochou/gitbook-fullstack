# 原子操作
对于一个 Go 程序来说, Go 语言运行时系统中的调试器, 会恰当地安排其中所有的 goroutine 的运行. 不过, 同一时刻, 只可能有少数的 goroutine 真正地处于运行状态, 并且这个数量是固定的. 所以, 为了公平起见, 调试器总是会频繁地切换这些 goroutine. 这个中断的时机有很多, 任何两条语句执行的间隙, 甚至在某条语句执行的过程中都是可以的. 互斥锁虽然可以保证临界区中代码的串行执行, 但却不能保证这些代码执行的原子性(atomicity).
在众多的同步工具中, 真正能够保证原子性执行的只有原子操作(atomic operation). **原子操作在运行的过程中是不允许中断的. 在底层, 这会由 CPU 提供芯片级别的支持, 所以绝对有效**.
正因为原子操作不能被中断, 所以它需要足够简单, 并且要求快速. 因此, 操作系统层面只对针对二进制位或整数的原子操作提供了支持.
一旦我们确定了在某个场景下可以使用原子操作函数, 比如只涉及并发地读写单一的整数类型值, 或者多个互不相关的整数类型值, 那就不要再考虑互斥锁了. 因为原子操作要比互斥锁快得多.
`sync/atomic` 包中的函数可以做的原子操作有: add, compare and swap(CAS), load, store, swap. 支持的类型有 int32, int64, uint32, uint64, uintptr, 以及 unsafe 包中的 Pointer. 此外, `sync/atomic` 包还提供了一个名为 Value 的类型, 它可以被用来存储任意类型的值.
所谓的 swap 指的是, 把新值赋给变量, 并返回变量的旧值. 而 CAS 操作会先判断被操作变量的当前值是否与我们预期的旧值相等, 如果相等, 它就把新值赋给该变量, 并返回 true 以表示交换操作已进行; 否则就忽略交换操作, 并返回 false.
CAS 操作有可能会引起 ABA 问题, 可使用 Hazard 指针解决. 参考: [Golang 无锁并发](https://github.com/dongjun111111/blog/issues/53).
使用 `atomic.Value` 存储值时, 有两条强制性规则. 一是不能用 `atomic.Value` 存储 nil; 二是存储值的类型不能变化(以第一次存储值的类型为基准).
`atomic.Value` 在首次真正使用后, 就不应该再被复制了.
尽量不要向 `atomic.Value` 中存储引用类型的值. 这很容易造成安全漏洞.

