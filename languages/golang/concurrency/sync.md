# 同步与锁
锁的主要作用就是保证多个 Goroutine 在访问同一片内存时不会出现混乱的问题. 锁其实是一种并发编程中的同步原语(Synchronization Primitives).
自旋(Spinnig)是在多线程同步的过程中使用的一种机制, 当前的进程在进入自旋的过程中会一直保持 CPU 的占用, 持续检查某个条件是否为真. 在多核 CPU 上, 自旋的优点是避免了 Goroutine 的切换. 所以如果使用恰当会对性能带来非常大的增益.


## 互斥锁(Mutex)
sync 包的 Mutex 类型支持 Lock 和 Unlock 操作. 用来保证他们之间的代码同一时间只有一个 goroutine 能访问.
我们总应该保证, 对于每一个锁定操作, 都要有且只有一个对应的解锁操作.
惯例来说, 被 Mutex 所保护的变量的声明应紧随 Mutex 的声明之后.
使用 `defer` 来调用 `Unlock` 方法, 以防忘记了解锁操作. `defer` 调用只会比显式地调用 `Unlock` 成本高那么一点点, 不过却在很大程度上保证了代码的整洁性. **对于大多数并发程序来说, 代码的整洁性比过度的优化更重要**.
`sync.Mutex` 类型是一个结构体, 属于值类型中的一种. 因此, 当你使用 `sync.Mutex` 时, 确保 `sync.Mutex` 和其保护的变量没有被导出(也不要在函数间传递或赋值给其他变量).
饥饿模式的主要功能是保证互斥锁获取的 "公平性(Fairness)".


