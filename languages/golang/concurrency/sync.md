# 同步与锁
所有并发的问题都可以用一致的, 简单的既定的模式来规避. 所以可能的话, 将变量限定在 goroutine 内部; 如果是多个 goroutine 都需要访问的变量, 使用互斥条件来访问.
对并发的直觉总是不能被会信任的.
概括来讲, 同步的用途有两个, 一个是避免多个线程在同一时刻操作同一个数据块, 另一个是协调多个线程, 以避免它们在同一时刻执行同一个代码块.
我们所说的同步其实就是在控制多个线程对共享资源的访问. 一个线程在想要访问某一个共享资源的时候, 需要先申请对该资源的访问权限, 并且只有在申请成功之后, 访问才能真正开始. 而当线程对共享资源的访问结束时, 它还必须归还对该资源的访问权限, 若要再次访问仍需申请.
锁的主要作用就是保证多个 Goroutine 在访问同一片内存时不会出现混乱的问题. 锁其实是一种并发编程中的同步原语(Synchronization Primitives).
自旋(Spinnig)是在多线程同步的过程中使用的一种机制, 当前的进程在进入自旋的过程中会一直保持 CPU 的占用, 持续检查某个条件是否为真. 在多核 CPU 上, 自旋的优点是避免了 Goroutine 的切换. 所以如果使用恰当会对性能带来非常大的增益.


## Mutex(互斥锁)
sync 包的 Mutex 类型支持 Lock 和 Unlock 操作. 用来保证他们之间的代码同一时间只有一个 goroutine 能访问.
我们总应该保证, 对于每一个锁定操作, 都要有且只有一个对应的解锁操作.
惯例来说, 被 Mutex 所保护的变量的声明应紧随 Mutex 的声明之后.
使用 `defer` 来调用 `Unlock` 方法, 以防忘记了解锁操作. `defer` 调用只会比显式地调用 `Unlock` 成本高那么一点点, 不过却在很大程度上保证了代码的整洁性. **对于大多数并发程序来说, 代码的整洁性比过度的优化更重要**.
`sync.Mutex` 类型是一个结构体, 属于值类型中的一种. 因此, 当你使用 `sync.Mutex` 时, 确保 `sync.Mutex` 和其保护的变量没有被导出(也不要在函数间传递或赋值给其他变量).
饥饿模式的主要功能是保证互斥锁获取的 "公平性(Fairness)".

## RWMutex(读写互斥锁)
`sync.RWMutex` 锁允许多个只读操作并行执行(`RLock`, `RUnlock`, 但写操作会完全互斥. 这种锁叫做 "多读单写" 锁.
相比于互斥锁(`sync.Mutex`), 读写锁可以实现更加细腻的访问控制.
对于某个受到读写锁保护的共享资源, 多个写操作不能同时进行, 写操作和读操作也不能同时进行, 但多个读操作却可以同时进行.

### WaitGroup
用于等待所有 goroutines 都完成后再进行后续操作. 这个函数可以让我们很方便的实现一对多的 goroutine 协作流程, 即: 一个分发子任务的 goroutine, 和多个执行子任务的 goroutine, 共同来完成一个较大的任务.
`sync.WaitGroup` 类型有三个指针方法: Add, Done 和 Wait.
不要把 Add 操作和 Wait 操作放在不同的 goroutine 中执行. 使用 "先统一 Add, 再并发 Done, 最后 Wait" 这种标准方式.
`sync.WaitGroup` 的值是可以被复用的, 但需要保证其计数周期的完整性(Add 后要再次归零).

### Once
sync.Once 可以保证其保护的代码可以安全的仅执行一次. 一般用于执行只应该执行一次的任务. 比如初始化连接池.
只要传入某个 Do 方法的参数函数没有结束执行, 任何之后调用该方法的 goroutine 就都会被阻塞. 只有在这个参数函数执行结束以后, 那些 goroutine 才会逐一被唤醒.