# Concurrency
## Note
**对并发的直觉总是不能被信任的**. 比起直觉更应该相信编译器的检查.
所有并发的问题都可以用一致的, 简单的既定的模式来规避. 所以可能的话, 将变量限定在 goroutine 内部; 如果是多个 goroutine 都需要访问的变量, 使用互斥条件来访问.
当我们没有办法确认一个事件是在另一个事件的前面或后面发生时, 我们就说这两个是事件是并发的.
并发安全的类型是例外, 而不是常态. 所以只有当文档中明确地说明了其是并发安全的情况下, 我们才可以并发地访问它.
**无论任何时候, 只要有多个 goroutine 并发访问同一变量, 且至少其中的一个是写操作的时候就会发生数据竞争**. 
一个好的经验法则是根本没有什么所谓的良性数据竞争. 所以我们一定要避免数据竞争.
一个做法是 "不要使用共享数据来通信, 使用通信来共享数据". 一个为变量提供 channel 请求的 goroutine 叫做这个变量的 monitor goroutine.
**一旦你决定了要对一个共享资源进行保护, 那就要做到完全的保护. 不完全的保护基本上与不保护没有什么区别**.


## Tools
在 build, run 或者 test 命令后加上 -race 参数, Go 编译器会为你生成一份竞争检查报告, 以便于查看并发可能导致的问题.
