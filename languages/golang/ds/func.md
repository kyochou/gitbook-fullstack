# 函数

## 语法
在函数调用时, Go 语言没有默认参数值, 也没有任何方法可以通过参数名指定形参. 因此每一次函数调用都必须按照声明顺序为所有参数提供实参(参数值).
所有函数参数都是值拷贝(浅拷贝)传入的. 
处理递归时, Go 语言使用了可变栈, 栈的大小按需增加. 这使得我们使用递归时不必考虑溢出和安全问题.
在 Go 中, 一个函数可以返回多个值. 许多标准库中的函数返回 2 个值, 一个是期望得到的返回值, 另一个是函数出错时的错误信息. 按照惯例, 函数的最后一个 bool 类型的返回值表示函数是否运行成功, error 类型的返回值代表函数的错误信息.
如果函数的所有返回值都是函数中的变量, 那么可以省略显式的 return 语句. 这称为 bare return.


函数的定义:
一个函数的声明包含 `func` 关键字, 函数名, 参数列表, 返回结果列表以及包含在大括号里的函数体.
只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的, 我们就可以说它们是一样的函数, 或者说是实现了同一个函数类型的函数.
严格来说, 函数的名称也不能算作函数签名的一部分, 它只是我们在调用函数时, 需要给定的标识符而已.
函数声明必须和大括号在一行.

```go
// 定义
func add(x int, y int) int {
    return x + y
}

// 当连续两个或多个已命名形参类型相同时, 除最后一个类型以外, 其它都可以省略.
func add(x, y int) int {
    return x + y
}

// 函数可返回任意数量的值.
func swap(x, y string) (string, string) {
    return y, x
}

// Go 的返回值可以被命名(返回值的定义不能与参数相同)
func swap(x, y string) (b, a string) {
    return y, x
}

// 没有参数的 return 语句返回已命名的返回值. 也就是直接返回
func swap(x, y string) (b, a string) {
    // 在此处给返回值赋值
	  a = x
	  b = y
    return
}

// 将函数声明为类型
type operate func(x, y int) int
```

## 错误
panic 是来自被调函数的信号, 表示发生了某个已知的 bug. 一个良好的程序永远不应该发生 panic 异常.
在 Go 的错误处理中, 错误是软件包 API 和应用程序用户界面的一个重要组成部分, 程序运行失败仅被认为是几个预期的结果之一.
对于那些将运行失败看作是预期结果的函数, 它们会返回一个额外的返回值(error 类型), 通常是最后一个, 来传递错误信息. 如果导致失败的原因只有一个, 额外的返回值可以是一个布尔值, 通常被命名为 ok.
io 包保证任何由文件结束引起的读取失败都返回同一个错误 -- `io.EOF`.

### 错误处理策略
1. 传播错误. 即在函数中直接返回失败.
 ```go
    doc, err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
    }
    ```
    
    `fmt.Errorf` 函数使用 `fmt.Sprintf` 格式化错误信息并返回. 我们可以使用该函数添加额外的上下文信息到原始错误中.
    由于错误信息经常是以链式组合在一起的, 所以错误信息中应该避免大写和换行符.
1. 如果错误的发生是偶然性的, 或由不可预知的问题导致的. 一个明智的选择是重新尝试失败的操作.
2. 如果错误发生后, 程序无法继续运行, 我们可以输出错误信息并结束程序(使用 `log.Fatalf` 或 `os.Exit` 函数).
3. 有时, 我们只需要输出错误信息就足够了, 不需要中断程序的运行. 可使用 log 包提供的函数实现.
4. 直接忽略错误.

**我们应该在每次函数调用后, 都养成考虑错误处理的习惯. 当你决定忽略某个错误时, 你应该清晰的记录下你的意图**.
**Go 中大部分函数的代码结构几乎相同, 首先是一系列的初始检查, 防止错误发生, 之后是函数的实际逻辑**.

## 函数值(函数变量)
在 Go 中, 函数值被看作第一类值(first-class values): 函数值像其他值一样, 拥有类型, 可以被赋值给其他变量, 传递给函数, 从函数返回. 对函数值的调用类似函数调用.
函数类型的零值是 nil, 函数值可以与 nil 比较, 但是函数值之间是不可比较的, 也不能用函数值作为 map 的 key.
对于函数类型来说, 它是一种对一组输入, 输出进行模板化的重要工具, 它比接口类型更加轻巧, 灵活, 它的值也借此变成了可被热替换的逻辑组件.
"函数是一等的公民" 是函数式编程(functional programming)的重要特征. Go 语言在语言层面支持函数式编程.


## 匿名函数 
函数字面量(function literal)是一种表达式, 它的值被称为匿名函数(anonymous function).
通过这种方式定义的函数可以访问完整的词法环境(lexical environment), 这意味着在函数中定义的内部函数可以引用该函数的变量.
Go 使用闭包(closures)技术实现函数值.
Go 函数可以是一个闭包. 闭包是一个函数值, 它引用了其函数体之外的变量. 该函数可以访问并赋予其引用的变量的值, 换句话说, 该函数被 "绑定" 在这些变量上.
**闭包函数的参数值为编译时绑定, 函数体内引用的外部变量为执行时绑定**.

## 参数

基础数据类型, 数组和结构体类型属于值类型. 字典, 通道, 函数等类型为引用类型. (函数参数)如果传递的值是引用类型的, 那么就是 "传引用". 如果传递的值是值类型的, 那么就是 "传值". 从传递成本的角度讲, 引用类型的值往往要比值类型的值低很多(值类型需要复制后传递).

## 可变参数
参数数量可变的函数称为可变参数函数. 在参数名后加 ... 表示这个函数接收任意数量的参数.
在函数中, 可变参数被看作是类型为数组的切片. 如果传递的可变参数为切片, 需要添加 ... 后缀.

```go
s := []int{1,2,3}
sum(1,2,3)
sum(s...)
func sum(vals ...int) int {
    // ...
}
```


## defer
`defer` 语句会将其语句后的函数推迟到外层函数返回之后执行. 推迟调用的函数其参数会立即求值, 但直到外层函数返回前该函数都不会被调用.
`defer` 一般用来执行各种清理操作.
推迟的(`defer`)函数调用会被压入一个栈中. 当外层函数返回时, 被推迟的函数会按照后进先出的顺序调用.
尽量把 `defer` 语句写在函数体的开始处. 因为如果有 Panic 被触发, 其后面的语句都不会再被执行到.
**函数返回的过程是这样的: 先给返回值赋值, 然后调用 defer 表达式, 最后才是返回到调用函数中**.
`defer` 函数中可以修改其所属函数的返回值:

```go
// 函数返回值为 2.
func c() (i int) {
	defer func() { i++ }()
	return 1
}
```

## 约定
### 函数名
后缀 f 代表该可变参数函数可以接收 Printf 风格的格式化字符串.

